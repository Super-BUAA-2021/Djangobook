# 详解 view.py

## 登录注册

### 完善视图函数

将之前写的注册函数改得完善亿点：

```python
from django.shortcuts import render
import json
from user.models import User
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
# Create your views here.

@csrf_exempt
def register(request):
	if request.method == 'POST':
		# 检测 POST 类型的请求
		
		data_json = json.loads(request.body)
		# 此时 data_json 已经转为了字典类型

		username = data_json['username']
		password1 = data_json['password1']
		password2 = data_json['password2']
		email = data_json.get('email', '')
		# 不确定是否有这个参数，使用get

		if password1 != password2:
			return JsonResponse({'result': 0, 'message': '两次密码不一致!'})
		# 虽然密码一致性与合法性检测一般是前端判断
		# 但是后端最好也加上，以防万一
		
		user = User(username=username, password=password1, email=email)
		# id 是自动赋值，不需要指明
		# post 不赋值会使用默认值0
		
		user.save()
		return JsonResponse({'result': 1, 'message': '注册成功!'})
		# 正常结束后需要给一个反馈信息
```



前后端在传递数据时，通常使用`json`格式。不了解`json`的同学看[这里](https://www.runoob.com/json/json-tutorial.html)。前端把要传的数据打包成 json 发给后端，后端解析这个 json 得到字典后，进行相应的处理，最后返回给前端一个 json 信息来告知处理结果。

```json
{
    'result': 1,
    'message': '注册成功!'
}
```



这是我个人经常用的一个返回信息模板，第一个参数0或1告诉前端是否正确处理了，后面一个参数则告诉详细的处理结果。比如由于两次密码不一致导致注册失败，前端就可以直接把 message 里的内容弹窗弹出来。

之所以选择 POST 类型的请求，是因为其更安全，数据内容不会携带在 URL中。同时它支持携带任意格式任意长度的请求参数，相对较为灵活。为了省事一点，可以要求前端只传 POST 类型的请求。POST 和 GET 的区别见[这里](https://www.runoob.com/tags/html-httpmethods.html)。

完善了注册函数后，再次启动项目（其实也不用每次都启动， 在启动状态下保存文件，Django 会自动检测并更新），用 postman 测一下注册功能是否正确。这次的请求因为带上了参数，所以需要在 body 中添加相应内容：

![image-20220124113023535](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241130578.png)



随便填一个最简单的管理员账号：

![image-20220124113118076](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241131111.png)



不出所料，得到了两次密码不一致的结果：

![image-20220124113154896](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241131929.png)

改成一致后再次发送请求，就可以看到正确的反馈信息：

![image-20220124113244159](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241132197.png)



在 Datagrip 中刷新一下 user 表，就能看到刚刚写入到数据库中的内容：

![image-20220124113326286](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241133322.png)



增删改查中的“增“，到这里已经结束了。

继续完善登录函数：

```python
@csrf_exempt
def login(request):
	if request.method == 'POST':
		data_json = json.loads(request.body)
		username = data_json['username']
		password = data_json['password']
		user = User.objects.get(username=username)
        # 查询语句，根据括号中的条件，返回唯一一条结果
        # 如果有多个表项匹配这一条件，则报错
        
		if user.password == password:
			return JsonResponse({'result': 1, 'message': '登录成功!'})
		else:
			return JsonResponse({'result': 0, 'message': '密码错误!'})
```



同时在`user/urls.py`中注册：

```python
from django.urls import path
from user.views import *

urlpatterns = [
	path('register', register),
	path('login', login),
]
```



postman 中新建一个 login 请求，进行测试：

![image-20220124114126103](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241141142.png)

![image-20220124114147873](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241141904.png)

两种情况都可以正常识别。但是，如果是下面这个情况，就会报错：

![image-20220124114407048](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241144110.png)



返回了一个 500 错误（~~恭喜你解锁了一个以后最常看见的错误代码~~）。仔细看下 Django 的终端输出：

![image-20220124155823649](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241558686.png)



查询结果不存在，这代表着`User.objects.get(username=username)`的获取结果为空。所以在不确定结果是否存在前，不能直接用`get`去查询，应该先检查存在性。查询部分应该修改为如下格式：

```python
if User.objects.filter(username=username).exists() == True:
    # 使用 filter 先检查存在性
    user = User.objects.get(username=username)
else:
	return JsonResponse({'result': 0, 'message': '用户不存在!'})
```



此时就可以正常处理用户不存在的情况了：

![image-20220124160326896](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241603933.png)



之前那个报错，渲染成 HTML 格式，长下面这样：

![image-20220124160500737](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241605784.png)

![image-20220124160508513](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241605550.png)



在`settings.py`中有一个参数，表示是否开启 DEBUG 模式，默认为 True。在这种情况下，报错会返回详细信息。在测试环境中不建议将其关闭，前端在浏览器中抓取到 500 错误后，可以查看返回信息，根据类似上面的报错信息提醒后端修 Bug。前后端对接的 debug 流程大概就是这样。



### 使用 session

在测试 login 接口时，发现存在一个问题，那就是后端无法检测登录状态，每次都认为是一个未登录用户在执行登录操作。这会带来很多问题，比如如果一个登录用户想查看自己所发表的博客，后端就无法进行正确的查询操作。

为解决这个问题，有两种办法：

1. 使用 token，也就是身份令牌。在登录成功后，后端会将一些信息加密传递给前端，加密后的结果就称为 token。每次前端在向后端发送请求时，都要携带这个token，后端在解密之后，就会知道用户名等各项信息。这种办法不需要前后端进行过多配置，实现原理简单；但每次前端传参时都需要手动加上 token。有关 token 的更多介绍，可以看[这里](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)。
2. 使用 session。这是 Django 官方推荐的方法。session 可以看做是一个存储信息的仓库，后端可以向 session 中写入、读取信息。在每次返回前端请求时，会自动捎带上 session id，前端将其存在cookie里，每次发请求就会自动发给后端。后端拿到id，先是自动去数据库中根据 id 找到session，然后就可以支持各种操作了。不过在跨域的情况下，前端如果想要保存 cookie，需要加很多额外的配置信息，但是后端用起来十分方便（~~我只负责出后端教程，肯定后端怎么方便怎么来，就让前端去解决这个问题吧~~）。

 

下面介绍 session 的使用。对登录函数做一些修改：

```python
@csrf_exempt
def login(request):
	if request.method == 'POST':
		id = request.session.get('id', 0)
		# 从 session 中获取信息
		if id != 0:
			return JsonResponse({'result': 0, 'message': '用户已登录!'})
		data_json = json.loads(request.body)
		username = data_json['username']
		password = data_json['password']
		if User.objects.filter(username=username).exists() == True:
			user = User.objects.get(username=username)
		else:
			return JsonResponse({'result': 0, 'message': '用户不存在!'})
		if user.password == password:
			request.session["id"] = user.id
			# 登录成功后就把 id 存进去
			
			return JsonResponse({'result': 1, 'message': '登录成功!'})
		else:
			return JsonResponse({'result': 0, 'message': '密码错误!'})
```



通过 session 来记忆当前登录的用户的 id 是什么。此时在进行多次登录测试：

![image-20220124163448542](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241634581.png)



就会发现已经可以正确识别登录状态了。

顺带加一个登出功能：

```python
@csrf_exempt
def logout(request):
	if request.session.get('id', 0) != 0:
		request.session.flush()
		# 清空所有的信息
		return JsonResponse({'result': 1, 'message': r'已登出!'})
	else:
		return JsonResponse({'result': 0, 'message': r'请先登录!'})
```



注册路由：

```python
from django.urls import path
from user.views import *

urlpatterns = [
	path('register', register),
	path('login', login),
	path('logout', logout),
]

```



测试：

![image-20220124163834559](https://raw.githubusercontent.com/zhtjtcz/MyImg/master/img/202201241638605.png)





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="gitalk-container"></div>
<script>
var gitalk = new Gitalk({
  "clientID": "0cfd2f1628066d69c6e3",
  "clientSecret": "303031b18a4deabc1164de81f2d78273c18f8415",
  "repo": "Djangobook",
  "owner": "Super-BUAA-2021",
  "admin": ["zhtjtcz"],
  "id": location.pathname,
  "distractionFreeMode": false  
});
gitalk.render("gitalk-container");
</script>