{"./":{"url":"./","title":"欢迎","keywords":"","body":"关于该教程 心血来潮写的一个 Django 后端入门级教程，随缘更新，有时间就填坑。咕咕咕咕咕咕 这个教程主要面向有一定 Python 编程基础，且对后端没有了解的同学。推荐在阅读本教程之前先自学 Python 的基础语法，以及 Ubuntu 操作系统的简单命令，本教程中不会提及这些内容。同时，本人秉持着不重复造教程的原则，对于网上教程非常丰富的内容，不会再重复给出指导（例如 Git 基本使用等，有很多高质量的教程）。 其他 版权归 Marvolo 所有。未经授权不得转载。 Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/0.html":{"url":"post/ch1/0.html","title":"第一章：Django 入门","keywords":"","body":"Django 入门 什么是Django Django 是一个由 Python 编写的一个开源 Web 应用框架。 使用 Django，只要很少的代码，就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务。Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式，MVC 模式使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。 为什么选择 Django 相较于 SpringBoot，Django 的上手门槛极低（这也和 Python 上手难度低有一定关系）。同为 Web 框架，Django 在实现同等服务时所需代码更少，在包管理方面做到了极致简洁。且由于 Python 拥有着极其丰富的第三方库，使得依托于 Django 的 Web 服务很容易增加新的功能。 当然，Django 并不是万能的。Django 自身的并发量上限是300，在极高并发的应用场景下，即使与 Nginx 搭配，Django 也很难胜任。而 SpringBoot 的历史更长，各方面相对来说没有太大的短板，比较受大型企业青睐；Django 作为近几年新兴的框架，更多地应用于中小型企业中。但是对于小规模需求，用 Django 开发是绰绰有余的。 不过随着其版本的不断迭代更新，也许在未来，Django 可能会击败 SpringBoot 成为第一后端框架也说不定呢。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"zhtjtcz\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/1.html":{"url":"post/ch1/1.html","title":"Python 环境配置与 Django 安装","keywords":"","body":"Python 环境配置与 Django 安装 Python 环境配置 Windows 用户 && Mac 用户 从长远角度考虑，我个人推荐安装 Anaconda 而不是直接装 Python。Anaconda 的集成度较高，自带很多库，创建虚拟环境也较为方便（日后如果要搞机器学习，大概率要用到虚拟环境），比较适合新手使用。 首先，来到清华镜像官网： 搜索 Anaconda： 依次点击 Anaconda、Archive，然后按时间排序： 各自选择最新版安装包下载安装即可。 安装基本上是一路无脑 next，但 Windows 用户在安装的时候有两个注意事项，第一，不要装在 C 盘，将安装路径改到 C 盘之外的任意一个英文路径下： 第二，记得勾选添加到环境变量中： Ubuntu 用户 你都自己折腾用上 Ubuntu了，应该会自己装 Python，这里不再给出教程。 IDE 选择 后端开发一般用vscode或者pycharm。我个人是使用vscode，这里有一份详细教程。后面的教程也会主要以 vscode 页面进行演示。 Pycharm 的话，可以看这里。 需要说明一下，后端开发时，通常是开着vscode/pycharm+postman+datagrip+firefox/chrome，非常吃内存。如果电脑内存紧张，同时开上面这些有明显卡顿，那就优先考虑vscode吧。一劳永逸的办法是再加个内存条。 Django 安装 在 vscode 的命令行中，输入pip install django，回车，等待安装完毕即可。不出意外应该安装的是 3.2 版本。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/2.html":{"url":"post/ch1/2.html","title":"熟悉 Django","keywords":"","body":"熟悉 Django 项目创建与运行 新建一个空目录，在这里打开一个命令行，输入 django-admin startproject hello 就可以创建第一个 Django 项目了。 然后用 VSCode 打开刚刚创建好的项目： 终端执行 python manage.py runserver 看到如下输出即为正常（无视红字部分）： 在浏览器中输入里面的地址：http://127.0.0.1:8000/，就可以看到如下页面： 这就说明你的第一个 Django 项目已经成功运行起来了！ 不幸的是，由于前后端分离开发的原因，这也是你最后一次在后端项目里看到页面，以后只能和接口与数据库打交道了 熟悉项目结构 在第一次运行后，整个项目结构应该长这样： hello ├─ db.sqlite3 ├─ hello │ ├─ __init__.py │ ├─ __pycache__ │ │ ├─ __init__.cpython-38.pyc │ │ ├─ settings.cpython-38.pyc │ │ ├─ urls.cpython-38.pyc │ │ └─ wsgi.cpython-38.pyc │ ├─ asgi.py │ ├─ settings.py │ ├─ urls.py │ └─ wsgi.py └─ manage.py 这些文件的作用分别为： db.sqlite3 ： sqlite 文件，也就是这个项目对应的数据库文件。 pyc 文件 ： py 文件编译后生成的字节码文件，不用管。 asgi.py ： 一个 ASGI 兼容的 Web 服务器的入口，以便运行你的项目。之后不需要修改。 settings.py ：该项目的设置文件。大部分关于项目的设置都要写入到这里。 urls.py：项目的 URL 声明。 wsgi.py ： 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。之后不需要修改。 manage.py ： 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 接下来会带大家熟悉应用的创建，url 配置与请求的处理。这可以说是该教程最最核心的一个部分。但是在开始之前，要先介绍两个工具：Postman 与 Datagrip。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/3.html":{"url":"post/ch1/3.html","title":"Postman 基本使用","keywords":"","body":"Postman 基本使用 简介 在前后端分离开发中，后端在很多情况下是不能通过图形化页面进行测试的。比如在开发完毕后，通过点击“登录”按钮，前端就会把文本框中的数据传递给后端，但是在开发完成前，可能连登录页面都没有，后端想要测试接口的正确性，就需要自己去“模拟”这么一个过程，自己发送登录请求来进行测试。 Postman 就是这么一个模拟请求的工具。 安装与配置 来到官网： 先注册一个账号，之后使用 Postman 的时候最好是登录状态，方便同步信息。然后下载，一路 next 安装，这个环节无坑点，正常走就行。 安装完毕并登录后，打开，页面应该长这样（我的是黑色是因为我改了颜色主题）： 点击Workspace，也就是工作区，为之前的 hello 项目新建一个工作区： 工作区权限随便设置一下，图省事直接 public： 创建完毕后，会自动打开新建的工作区，点击左侧的加号，新建一个文件夹（虽然请求可以不放在文件夹中，但是一个 Django 项目下一般有很多应用，按应用把请求归类较为方便）： 右键，Add Request，可以新建一个请求，创建完毕后如下图所示： 在 URL 一栏随便填一个网页，比如百度，然后点击 Send，就可以在下面看到返回结果了： 点击 Preview 就会让 Postman 渲染所拿到的 HTML 信息： 之后更多会使用 POST 请求，且来回传递的信息都是 json 格式。在之后进行登录注册时会进一步介绍。目前这个阶段，只要能看到上面的页面，会创建、归类新请求即可。 使用技巧 在后端测试时，如果部署在云端，往往有两个地址：127.0.0.1 和云端的服务器IP。有时一个接口在本地和云端都会进行测试，手动反复改 IP 很麻烦，这时就可以使用环境变量来简化这个过程。 点击左侧Environment，点击Globals，新建一个变量local，填入本地的IP与端口： 在刚刚的请求页面就可以使用这个环境变量来替代后面那么长的 IP 信息了。格式是{{变量名}}。例如下面这样： 每次只需要修改括号中的变量名，就可以快速完成 IP 切换，十分方便。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/4.html":{"url":"post/ch1/4.html","title":"Datagrip 基本使用","keywords":"","body":"Datagrip 基本使用 学生认证 来到 JetBrain 官网，注册账号： 然后来到这个页面申请学生认证： 比较遗憾的是，由于 BUAA 毕业后不注销邮箱，JB ban掉了 BUAA 邮箱学生认证。所以只能走人工审核通道，先去学信网开一个PDF证明，然后上传等待人工审核。一般两天内就可以出结果： 审核完毕后就可以快乐地白嫖 JB 全家桶了~ 如果嫌麻烦（？），也可以去找破解版资源，这里就不给出教程了（我用的是正版，破解版去哪找我也不知道）。 安装 来到 Datagrip 页面，正常下载安装： 安装完毕后记得登录自己已经完成学生认证的账号，然后随便新建一个项目进入 Datagrip 主页面。 汉化与插件 点击左上角Files->Settings->Plugins，搜索Chinese，出来的第一个就是汉化插件。点击安装即可。 安装完毕后应该会提示重启生效，不要着急，可以一次性装完再重启。我个人除了汉化插件外，还打了两个美化插件： 一个改图标，一个改 UI。都安装完毕后重启，就可以看到一个崭新的中文的 Datagrip 了。至于连接数据库进行增删改查，在后面的章节会详细介绍。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/5.html":{"url":"post/ch1/5.html","title":"应用创建与数据库初始化","keywords":"","body":"应用创建与数据库初始化 从这个小节开始，就会带大家一步步搭建一个简单的 Django 博客项目出来。整个项目大概有如下功能：用户注册/登录，发布文章，查看文章。在实现这些功能的过程中，会逐一介绍 Django 框架的基本特点与使用。 应用创建 首先，用 VSCode 打开之前创建好的hello项目。Django 这个框架是依托于应用的，一个 Django 项目是一个个应用所构成的。这里使用下面的命令创建第一个应用： python manage.py startapp user 可以看到项目的根目录下多了一个user文件夹： 这就是刚刚创建好的应用，之后会在这个应用中实现用户模块。 连接数据库 用之前介绍的 Datagrip，先连接上本项目的数据库。打开 Datagrip，选择数据源->Sqlite： 名称随便填写，然后选中项目中的那个 sqlite 文件： 然后就可以在左侧看到数据库了： 下一步就是创建数据库表。 建表 这里默认大家已经掌握基本的数据库知识（主键，外键等）。 打开user/models.py，然后将其修改为如下内容： from django.db import models # Create your models here. class User(models.Model): id = models.AutoField(primary_key=True) username = models.CharField(max_length=20) password = models.CharField(max_length=50) email = models.EmailField(null=True, blank=True) post = models.IntegerField(default=0) User就是我们新建的一个数据库表，同时它也是 Python 中的一个类。这个类中的每一个属性，都会对应表中的每一列。首先定义id为主键，其类型为AutoField，表示我们在初始化这个类时，不需要显式为其赋值，Django 会自动计算它的值。比如数据库中已经有了 3 个用户，在新建第四个用户时，id会被自动置为4。 然后是每个用户必备的用户名与密码类，通常这两个属性都不会很长，使用CharField类型储存，并设置最大长度。用户在注册时可以选择提供邮箱，存放于EmailField，也就是邮箱类中。考虑到可能有缺失的情况，所以允许这一个属性为空。最后一个post来记录这个用户一共发表了多少篇博客，其类型是整形IntegerField。在初始化时如果未被给出，则赋一个默认值 0 进去。 因为刚刚对数据库做了修改，我们需要将这些修改迁移进去。在命令行中输入以下两条命令： python manage.py makemigrations python manage.py migrate 发现没有反应。因为新建的应用没有写入到项目设置中。打开hello/settings.py，在这里把user这个应用写入： 然后再执行上面的命令： Django 就会识别刚刚建好的表，并且把每个属性的信息写入。在 Datagrip 中刷新下对应的数据库，就可以在其中看到刚刚建好的表了： 注：user_user是默认的应用名_表名的格式，并不是写法有问题。 到这里一个新的应用的初始化过程就已经结束了。相关代码已经提交到了 Github 的示例项目上，最后一次 commit 的注释为“Finish APP Create”。 注意事项 有关数据库的一切操作都要慎重。一个项目通常会在需求都非常明确之后，才确定要建哪些表、表之间有什么关系、表中都有哪些属性。如果需求不明确就随意建表，很容易在后期发现字段不够用，字段没用上，表太大过于臃肿需要拆分等情况，这时候再对表进行修改会麻烦很多。例如要在一个已有的表中加入一个新的字段，且这个表里已经有一部分数据的话，就需要允许这个新字段为空，或者指定默认值，不然加不进去。 这些对表的操作一个不慎就会产生很多脏数据，干扰正常的增删改查，最后只能删库处理。所以在建表时一定要慎重，少用外键（因为初学者再怎么被强调，自己上手开发或多或少都得改个十几次表，少用外键可以避免出现问题）。 参考资料 Django 支持的字段类型有很多，这里只对用到的类型做了简单介绍。如果有别的需求，可以查阅官方文档-模型字段参考。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/6.html":{"url":"post/ch1/6.html","title":"URL 管理","keywords":"","body":"URL 管理 URL 与路由 在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫 URL。在 Django 中，会根据用户请求的 URL 链接来判断对应的处理程序，并返回处理结果，也就是 URL 与 Django 的视图建立映射关系，这个关系也被称为路由。 举个栗子，你去访问0.0.0.0:8000/test，Django 识别到这个地址的 URL 是test，它就会先去urls.py中查表，检查应该调用哪个函数对这个请求进行处理，这个过程就是通过路由管理实现的。 用户注册 创建视图 打开user/views.py，这里将会存放一个个视图函数，来处理每一次 URL 请求。在里面新建一个注册函数： from django.shortcuts import render import json from user.models import User from django.http import JsonResponse # Create your views here. def register(request): if request.method == 'POST': print(\"POST\") return JsonResponse({'result': 1, 'message': '注册成功!'}) 这个函数体会在下一个小节进一步完善，目前只是用来测试路由是否配置正确。 注册 URL 在user下新建urls.py，在其中写入如下内容： from django.urls import path from user.views import * urlpatterns = [ path('register', register), # 前一项是URL，后面是绑定的 views 中的函数 # 当匹配到'register'这个 URL 时 # 将参数传递进 register 函数进行处理 # 名字允许不一致，一般写成一样的清晰一些 ] 同时，修改hello/urls.py中的内容： from django.contrib import admin from django.urls import path,include urlpatterns = [ path('admin/', admin.site.urls), path('user/', include(('user.urls', 'user'), namespace=\"user\")), # 新增对 user/ 的匹配 ] 在当前的 URL 配置下，当后端收到一条形如IP:端口/user/register的请求后，会先去hello/urls.py中进行匹配，其中user/被匹配上，于是去user/urls.py中继续匹配，URL 中的register被匹配上后，就会转到register函数进行处理。 这种将一个应用中的 URL 在项目的urls.py中注册为一条的写法可以让路由配置更加清晰。其实也可以直接在hello/urls.py中写明user/register直接转register函数，但是当一个项目中的接口多起来之后，很难找到谁对应谁，按应用分别注册更方便管理。 Postman 测试接口 路由都配置完毕后，接下来测试接口的正确性。打开 Postman，在user文件夹下新建一个请求： 将请求类型改为 post，并填入地址： 启动 Django 项目，然后点击send，发现报错，出现了跨域的问题： 修改一下views.py，改成下面格式： from django.shortcuts import render import json from user.models import User from django.http import JsonResponse from django.views.decorators.csrf import csrf_exempt # 引入解决跨域问题的修饰符 # Create your views here. @csrf_exempt # 修饰符，URL 绑定的每个函数都要加这个东西 def register(request): if request.method == 'POST': print(\"POST\") return JsonResponse({'result': 1, 'message': '注册成功!'}) 这时候再启动项目，发送请求，就可以看到正常结果： 请求返回值为 200，相应时间 10 ms，返回结果渲染正常。这就说明路由已经正确配置了。 到这里路由配置过程就已经结束了。相关代码已经提交到了 Github 的示例项目上，最后一次 commit 的注释为“Finish URL”。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/7.html":{"url":"post/ch1/7.html","title":"详解 views.py","keywords":"","body":"详解 view.py 登录注册 完善视图函数 将之前写的注册函数改得完善亿点： from django.shortcuts import render import json from user.models import User from django.http import JsonResponse from django.views.decorators.csrf import csrf_exempt # Create your views here. @csrf_exempt def register(request): if request.method == 'POST': # 检测 POST 类型的请求 data_json = json.loads(request.body) # 此时 data_json 已经转为了字典类型 username = data_json['username'] password1 = data_json['password1'] password2 = data_json['password2'] email = data_json.get('email', '') # 不确定是否有这个参数，使用get if password1 != password2: return JsonResponse({'result': 0, 'message': '两次密码不一致!'}) # 虽然密码一致性与合法性检测一般是前端判断 # 但是后端最好也加上，以防万一 user = User(username=username, password=password1, email=email) # id 是自动赋值，不需要指明 # post 不赋值会使用默认值0 user.save() return JsonResponse({'result': 1, 'message': '注册成功!'}) # 正常结束后需要给一个反馈信息 前后端在传递数据时，通常使用json格式。不了解json的同学看这里。前端把要传的数据打包成 json 发给后端，后端解析这个 json 得到字典后，进行相应的处理，最后返回给前端一个 json 信息来告知处理结果。 { 'result': 1, 'message': '注册成功!' } 这是我个人经常用的一个返回信息模板，第一个参数0或1告诉前端是否正确处理了，后面一个参数则告诉详细的处理结果。比如由于两次密码不一致导致注册失败，前端就可以直接把 message 里的内容弹窗弹出来。 之所以选择 POST 类型的请求，是因为其更安全，数据内容不会携带在 URL中。同时它支持携带任意格式任意长度的请求参数，相对较为灵活。为了省事一点，可以要求前端只传 POST 类型的请求。POST 和 GET 的区别见这里。 完善了注册函数后，再次启动项目（其实也不用每次都启动， 在启动状态下保存文件，Django 会自动检测并更新），用 postman 测一下注册功能是否正确。这次的请求因为带上了参数，所以需要在 body 中添加相应内容： 随便填一个最简单的管理员账号： 不出所料，得到了两次密码不一致的结果： 改成一致后再次发送请求，就可以看到正确的反馈信息： 在 Datagrip 中刷新一下 user 表，就能看到刚刚写入到数据库中的内容： 增删改查中的“增“，到这里已经结束了。 继续完善登录函数： @csrf_exempt def login(request): if request.method == 'POST': data_json = json.loads(request.body) username = data_json['username'] password = data_json['password'] user = User.objects.get(username=username) # 查询语句，根据括号中的条件，返回唯一一条结果 # 如果有多个表项匹配这一条件，则报错 if user.password == password: return JsonResponse({'result': 1, 'message': '登录成功!'}) else: return JsonResponse({'result': 0, 'message': '密码错误!'}) 同时在user/urls.py中注册： from django.urls import path from user.views import * urlpatterns = [ path('register', register), path('login', login), ] postman 中新建一个 login 请求，进行测试： 两种情况都可以正常识别。但是，如果是下面这个情况，就会报错： 返回了一个 500 错误（恭喜你解锁了一个以后最常看见的错误代码）。仔细看下 Django 的终端输出： 查询结果不存在，这代表着User.objects.get(username=username)的获取结果为空。所以在不确定结果是否存在前，不能直接用get去查询，应该先检查存在性。查询部分应该修改为如下格式： if User.objects.filter(username=username).exists() == True: # 使用 filter 先检查存在性 user = User.objects.get(username=username) else: return JsonResponse({'result': 0, 'message': '用户不存在!'}) 此时就可以正常处理用户不存在的情况了： 之前那个报错，渲染成 HTML 格式，长下面这样： 在settings.py中有一个参数，表示是否开启 DEBUG 模式，默认为 True。在这种情况下，报错会返回详细信息。在测试环境中不建议将其关闭，前端在浏览器中抓取到 500 错误后，可以查看返回信息，根据类似上面的报错信息提醒后端修 Bug。前后端对接的 debug 流程大概就是这样。 使用 session 在测试 login 接口时，发现存在一个问题，那就是后端无法检测登录状态，每次都认为是一个未登录用户在执行登录操作。这会带来很多问题，比如如果一个登录用户想查看自己所发表的博客，后端就无法进行正确的查询操作。 为解决这个问题，有两种办法： 使用 token，也就是身份令牌。在登录成功后，后端会将一些信息加密传递给前端，加密后的结果就称为 token。每次前端在向后端发送请求时，都要携带这个token，后端在解密之后，就会知道用户名等各项信息。这种办法不需要前后端进行过多配置，实现原理简单；但每次前端传参时都需要手动加上 token。有关 token 的更多介绍，可以看这里。 使用 session。这是 Django 官方推荐的方法。session 可以看做是一个存储信息的仓库，后端可以向 session 中写入、读取信息。在每次返回前端请求时，会自动捎带上 session id，前端将其存在cookie里，每次发请求就会自动发给后端。后端拿到id，先是自动去数据库中根据 id 找到session，然后就可以支持各种操作了。不过在跨域的情况下，前端如果想要保存 cookie，需要加很多额外的配置信息，但是后端用起来十分方便（我只负责出后端教程，肯定后端怎么方便怎么来，就让前端去解决这个问题吧）。 下面介绍 session 的使用。对登录函数做一些修改： @csrf_exempt def login(request): if request.method == 'POST': id = request.session.get('id', 0) # 从 session 中获取信息 if id != 0: return JsonResponse({'result': 0, 'message': '用户已登录!'}) data_json = json.loads(request.body) username = data_json['username'] password = data_json['password'] if User.objects.filter(username=username).exists() == True: user = User.objects.get(username=username) else: return JsonResponse({'result': 0, 'message': '用户不存在!'}) if user.password == password: request.session[\"id\"] = user.id # 登录成功后就把 id 存进去 return JsonResponse({'result': 1, 'message': '登录成功!'}) else: return JsonResponse({'result': 0, 'message': '密码错误!'}) 通过 session 来记忆当前登录的用户的 id 是什么。此时在进行多次登录测试： 就会发现已经可以正确识别登录状态了。 顺带加一个登出功能： @csrf_exempt def logout(request): if request.session.get('id', 0) != 0: request.session.flush() # 清空所有的信息 return JsonResponse({'result': 1, 'message': r'已登出!'}) else: return JsonResponse({'result': 0, 'message': r'请先登录!'}) 注册路由： from django.urls import path from user.views import * urlpatterns = [ path('register', register), path('login', login), path('logout', logout), ] 测试： 发表博客 完善了登录注册这些基本功能后，就要开始着手实现博客相关的接口了。首先是创建一个新的APP，命名为post，表示博客相关模块： python manage.py startapp post 然后去settings.py中注册，再在post/models.py里初始化一下博客数据库： from django.db import models # Create your models here. class Post(models.Model): id = models.AutoField(primary_key=True) # 主键 uid = models.IntegerField() # 发表该博客的用户id # 也可以选择用外键连接到User表中 title = models.CharField(max_length=50) # 博客标题 article = models.TextField(null=True, blank=True) # 博客正文 # 因为可能很长，所以使用 TextField 字段 time = models.DateTimeField() # 发表时间 然后三板斧迁移一下，同步到本地的数据库文件里： python manage.py makemigrations python manage.py migrate python manage.py runserver DataGrip 中刷新就可以看到新建的表了： 接下来是完善views.py，实现发表博客的功能。参考代码如下： from django.shortcuts import render import json from django.http import JsonResponse from django.views.decorators.csrf import csrf_exempt from post.models import * from user.models import * from datetime import datetime # Create your views here. @csrf_exempt def create(request): if request.method != 'POST': return JsonResponse({'result':0, 'message':'Error'}) id = request.session.get('id', 0) if id == 0: return JsonResponse({'result':0, 'message':r'请先登录'}) data_json = json.loads(request.body) post = Post( uid = id, title = data_json['title'], article = data_json['article'], time = datetime.now() ) post.save() # 存储新博客文章信息 user = User.objects.get(id = id) user.post += 1 user.save() # 更新发表文章数量 关于 URL 的配置，同user模块，这里只给出修改后的结果： hello/urls.py from django.contrib import admin from django.urls import path,include urlpatterns = [ path('admin/', admin.site.urls), path('user/', include(('user.urls', 'user'), namespace=\"user\")), path('post/', include(('post.urls', 'post'), namespace=\"post\")), ] post.urls.py from django.urls import path from post.views import * urlpatterns = [ path('create', create), ] 运行，在 Postman 中简单测试一下： 就可以在数据库中看到相应的结果了： 发表完博客后，下一步是查看。由于不知道用户会点开哪一篇博客，所以要先给前端当前用户所发表的博客列表，用户点击之后，再去精确获取详细的正文信息。涉及到的函数如下： @csrf_exempt def get_list(request): if request.method != 'POST': return JsonResponse({'result':0, 'message':'Error'}) data_json = json.loads(request.body) id = int(data_json['id']) # 这里是用户id，获取这个用户所发表的所有文章 posts = [{ 'id': x.id, 'title': x.title, 'time': x.time } for x in Post.objects.filter(uid = id)] # filter 的结果是一个类似列表的可迭代元素 # 故可以使用 for .. in 去遍历 # 这其实是一种压行写法 return JsonResponse({'result':1, 'message':r'获取成功', 'posts':posts}) @csrf_exempt def get_post(request): if request.method != 'POST': return JsonResponse({'result':0, 'message':'Error'}) data_json = json.loads(request.body) id = int(data_json['id']) # 这里是文章id post = Post.objects.get(id = id) return JsonResponse({'result':1, 'message':r'获取成功', 'post': post.to_dic()}) # 注意这里使用了to_dic()函数 Django 中的数据库定义是使用的类的形式，既然是类，就可以在里面声明函数。to_dic的定义如下： class Post(models.Model): id = models.AutoField(primary_key=True) # 主键 uid = models.IntegerField() # 发表该博客的用户id # 也可以选择用外键连接到User表中 title = models.CharField(max_length=50) # 博客标题 article = models.TextField(null=True, blank=True) # 博客正文 # 因为可能很长，所以使用 TextField 字段 time = models.DateTimeField() # 发表时间 def to_dic(self): return { 'id': self.id, 'title': self.title, 'time': self.time, 'article': self.article, 'uid': self.uid } 之所以要加一步到字典的转换，这是因为 get 得到的结果是 Post 类型，如果直接放到 json 中传递给前端，会在打包转换的时候出现格式错误而报错。json 只能认字典，列表等基础类型，所以一定要加这么一个步骤。 测试结果如下： 最后顺手补一个删除博客的功能： @csrf_exempt def delete_post(request): if request.method != 'POST': return JsonResponse({'result':0, 'message':'Error'}) data_json = json.loads(request.body) id = int(data_json['id']) # 这里是文章id post = Post.objects.get(id = id) user = User.objects.get(id = post.uid) user.post -= 1 user.save() # 记得先更新发表文章数量 post.delete() return JsonResponse({'result':1, 'message':r'删除成功'}) 到这里，数据库最基本的增，删，改，查四种情况都已经覆盖到了。之后实现的视图函数，基本上就是以上的各种变种，只不过业务逻辑上可能复杂一些， 比如一次涉及到多个表的查询，表之间信息同步更加复杂，数据库中的原始数据有时候不能直接给后端要先本地处理（例如要根据某个统计数据让前端画图等）。 同一个功能的实现是多样的。比如上面获取发表文章列表，其实可以直接把这个文章的所有详细信息全部返回给前端，这样前端在点击某个博客的页面的时候，就可以根据已有的数据直接渲染，不再向后端请求，可以大大提升相应速度。但是在发表博客数很多，博客正文很长的情况下，这么实现会导致在获取列表时相应时间变长，同时一次返回过多数据也会给带宽带来很大的压力。这就需要前后端对业务做一个合理的切割，来得到一个多方面平衡的接口实现方案。 到这里视图函数讲解过程就已经结束了。相关代码已经提交到了 Github 的示例项目上，最后一次 commit 的注释为“Finish view”。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/8.html":{"url":"post/ch1/8.html","title":"跨域，调试与部署","keywords":"","body":"跨域，调试与部署 严格来说，这个章节应该放到第二章之后，在购买并完成服务器基础配置后再将后端项目迁移到服务器上。但由于跨域问题的解决需要在后端代码中修改很多东西，为保证教程学习体验，决定将这一小部分内容提前。所以阅读本小节之前请先阅读第二章中服务器购买与配置部分。 什么是跨域 所谓跨域，就是指浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，就是跨域访问 。同域就是域名、端口、协议全部都相同，我们称之为同域访问。在实际部署中，最常见的导致跨域的原因就是前端和后端部署在两台不同的服务器上。如果产生了跨域，后端服务就无法正常访问，影响网站的运行。为解决这个问题，需要在后端的配置文件中做一些修改。 跨域的解决 首先，在本地以及服务器上安装一个 Django 插件： pip install django-cors-headers 然后在项目的settings.py中，进行如下配置： INSTALLED_APPS = [ ...... 'corsheaders', ...... ] MIDDLEWARE = [ ...... 'corsheaders.middleware.CorsMiddleware', 'django.middleware.common.CommonMiddleware',# 注意顺序 ...... ] ALLOWED_HOSTS = ['*'] # 注意这里是修改，原本是[] # 跨域增加忽略 CORS_ALLOW_CREDENTIALS = True CORS_ORIGIN_ALLOW_ALL = True CORS_ALLOW_METHODS = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'VIEW', ) CORS_ALLOW_HEADERS = ( 'XMLHttpRequest', 'X_FILENAME', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with', 'Pragma', ) 修改完成后，就可以在云端进行测调试了。修改完成后的代码已同步至示例项目中，对应提交为fix: cors error。 云端调试 购买的腾讯云服务器默认是带有 Git 的，可以通过下面的命令查看版本： git --version 直接使用 Git ，通过下面的命令将示例项目拉取到服务器上： git clone https://github.com/Super-BUAA-2021/Django-demo.git 成功拉取后可以看到如下输出： 进入项目文件夹，将其运行起来： python manage.py runserver 0.0.0.0:8000 然后在 Postman 中测试下接口： 箭头指的地方需要换成服务器IP:端口。如果一切正常，就会看到和本地一样的返回结果。至此，后端就可以在云端正常运行并可以向前端提供服务了。 但是，上面这种运行方法有一个缺陷，如果关掉链接服务器的程序，则后端程序也会被中止，所以需要调整下运行的方式。在项目文件夹下新建run.py，里面内容为： import os import platform os.system(\"python manage.py makemigrations\") os.system(\"python manage.py migrate\") if platform.system() != \"Linux\": os.system(\"python manage.py runserver\") # 本地环境，直接运行 else: os.system(\"python manage.py runserver 0.0.0.0:8000 > log.txt & \\n\") print(\"The backend is running!\") # 服务器环境，后台运行 新建kill.py： import os os.system(\"ps -ef | grep \\\"runserver\\\" > log.txt\") F=open(\"log.txt\",\"r\") a = F.readline().split() b = F.readline().split() print(\"The process id are %s and %s.\"%(a[1],b[1])) os.system(\"kill -9 \" + a[1]) os.system(\"kill -9 \" + b[1]) print(\"They have been successfully killed!\") # Django 在后台运行时会产生两个进程 # 通过命令找出并 kill 掉 以后在运行后端项目时，只需要python run.py即可，本地和服务器端都是这句命令。在服务器端想更新下后端代码，则需要先用python kill.py杀掉上次的项目，然后git pull什么的随便更新下，再运行即可。 大概效果如下图所示： 当然，在一些情况下，需要改成手动运行的模式。比如在对接时出现了 500 错误，除了让前端在浏览器中翻出来报错信息，更方便的做法是改成手动运行模式然后看后端的报错输出。 总结 到这里，后端就可以在服务器上 24 小时运行了。如果上面两个小脚本如果有更好的写法，欢迎在评论区交流。示例项目已完成对应的修改，最后一次提交为add: run && kill。 关于 Git，我所购买的腾讯云服务器可以直接clone和pull，速度非常快，没有出现超时无法连接的情况。如果发生超时，需要手动进行一定的配置，本教程就不再展开介绍（主要是配置这东西很玄学）。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch1/9.html":{"url":"post/ch1/9.html","title":"其他","keywords":"","body":"Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch2/0.html":{"url":"post/ch2/0.html","title":"第二章：登陆服务器","keywords":"","body":"标题 Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch2/1.html":{"url":"post/ch2/1.html","title":"腾讯云服务器购买与配置","keywords":"","body":"腾讯云服务器购买 准备工作 首先，来到腾讯云的官网： 正常注册登录，并用身份证完成实名认证。这一步很重要，这关系到后面能不能使用学生优惠。 认证完毕后，点击上方“最新活动”，选择“云+校园专区”： 因为已经完成了实名认证，且腾讯云25岁以下默认享有学生优惠，所以不需要再认证学生证，就可以享受优惠价。服务器有两种型号： 1核2G的服务器足够满足课内需求。想利用云服务器搭建其他服务的，也可以选择2核4G。时长方面，建议一次购买2年，因为最后一次写网站是在大三下之后的暑假，之后还要用到。 选择了型号与时长后，有一个环节是选择操作系统，这里建议选择Ubuntu 20.04 LTS，自带Python。之后正常付费，然后等待资源分配。分配完毕后可以在控制台->轻量云服务器页面看到： 上图中就是一个已经运行了一段时间的服务器，型号是2核4G的。 服务器到手后，第一步，重置密码，点击重置密码按钮，先重置默认的Ubuntu用户的密码： 关机重启等重置完毕后，再重置一下 root 用户的密码： 之后如果要使用 root 账户连接，需要先用 ubuntu 用户登录对系统做一些修改，具体参见官方教程。 连接与环境配置 想要连接到云服务器，要满足下面两个条件： 云服务器有公网IP，且开放了对外连接的端口 本地有支持 SSH 服务的软件。 第一个条件是自动满足的，所以只需要安装一款用于远程连接的软件即可。有两种选择，MobaXterm 和 Tabby Terminal。前者功能强大，后者轻量快捷，可以根据需求选择使用。 MobaXterm 教程 Tabby Terminal 教程 连接完毕后，先查看一下环境： python -V 服务器自带 Python 3.8 环境，不需要手动配置。所以直接安装 Django： pip install django 这时基本的环境已经配好了。如果Django 项目中有依赖别的第三方库，手动 pip 一下即可。 防火墙设置 Django 项目一般运行在8000端口，也可以自己指定。前端必须知道后端服务器的 IP 与端口才可以访问 Django 服务。回到控制台页面，点击防火墙，可以看到目前白名单中放行的端口： 点击添加规则，创建一个新的规则进去： 上面的 8000 也可以换成别的数字。然后在服务器上可以创建一个简单的项目，运行一下： django-admin startproject hello cd hello python manage.py runserver 0.0.0.0:8000 # 这里和刚刚的设置要保持一致 然后在本机电脑上，输入IP:端口，看到如下页面就说明配置成功： 这是一个跨域报错页面，能看到这个页面说明确实访问到了 Django 服务，只不过跨域了。按照之前的教程把跨域设置好之后就能正常使用接口了。 Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch2/2.html":{"url":"post/ch2/2.html","title":"腾讯云数据库购买与配置","keywords":"","body":"标题 Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch3/0.html":{"url":"post/ch3/0.html","title":"第三章：Git 与自动部署","keywords":"","body":"Github 与自动部署 这一章节主要介绍 Github 与 Git 的使用，以及如何利用 Github Action 服务实现后端的自动部署。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch3/1.html":{"url":"post/ch3/1.html","title":"Git 入门","keywords":"","body":"Git 入门 Git ，一个开源的分布式版本控制系统，团队合作利器。对于小规模网站开发而言，只需要掌握提交，分支切换与合并，stash 的简单使用这三大功能，即可应付99%的开发场景。对于版本回退等特殊需求，随用随 Google 就好。 安装 直接来到官网： 点击按钮下载，一路next安装即可。 入门教程 继续遵循不重复造教程的原则，这里直接给出一些不错的教程： Git 入门|菜鸟教程 Git 入门|廖雪峰 Git 实战练习：可以通过类似玩游戏的方式带你熟悉 Git。 个人建议 多人开发时，一般是一个 master 主分支，每个人再单独创建一个个人分支。每次先在自己的分支上完成开发任务并通过测试后，再 merge 到 master 上。谁 merge 的时候发生冲突谁负责解决。每次开发前记得先和 master 保持进度同步。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch3/2.html":{"url":"post/ch3/2.html","title":"Github 介绍","keywords":"","body":"标题 Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "},"post/ch3/3.html":{"url":"post/ch3/3.html","title":"Github Action 实现自动部署","keywords":"","body":"Github Action 实现自动部署 简介 Github 针对开发者提供了很多免费的实用工具，Github Action 就是其中之一。你可以将其理解为一个特殊的脚本，在满足一定条件的时候它就会执行（例如检测到对某一分支的push，到达了一天的0点等）。 在网站开发中，后端经常需要把刚写完的内容同步至服务器端供前端测试，如果手动部署，则需要先连接服务器，然后git pull，再将后端运行起来。一次两次还好，多了之后会很浪费时间且比较枯燥。适当使用 Github Action 就可以把这个过程自动化，下面将介绍如何实现自动部署。 准备工作 在一个git项目中，新建一个.github文件夹，再在其中新建一个workflows文件夹，然后在里面创建一个main.yml的文件，将下面的内容粘贴进去： name: Django_deploy on: push: branches: [master] jobs: build: runs-on: ubuntu-latest steps: - name: pull and reload on Aliyun run: sshpass -p ${{secrets.ECS_PASSWORD}} ssh -o StrictHostKeyChecking=no root@${{secrets.ECS_IP}} \"cd ~/academic; python kill.py; git pull --force; git checkout master; python run.py;\" 此时先不要急着 commit，进入Github 里对应的仓库页面，点击Settings->Secrets（如果找不到Secrets，可能是权限不够，可以让仓库拥有者来操作）。这里存放的是这个仓库中的所需要的不对外公开的常量。点击创建新 Secrets： 然后分别填入常量名和值： 上面的yml文件用到了两个常量，分别是ECS_PASSWORD与ECS_IP。前者是你服务器的密码，后者是服务器的 IP。将这两个常量创建好后，效果如下图所示： 这个时候就不能再看到这个常量的值了，只能修改或者删除。之所以这么操作，是考虑到之后仓库可能改成 public，为了避免服务器的信息泄露，于是使用了 Secrets 来做一个安全防护。 脚本中的这几句比较关键： on: push: branches: [master] 它指明了脚本运行的时机，是在检测到 master 分支上有新的push的时候，就会执行脚本。可以根据实际情况修改分支名称。 这里着重对这句话做一个解释： run: sshpass -p $ ssh -o StrictHostKeyChecking=no root@$ \"cd ~/academic; python kill.py; git pull --force; git checkout master; python run.py;\" run就是执行后面的内容。首先使用 sshpass 连接上服务器，IP 与密码在 Secrets 中设置好了。然后在服务器上执行引号中的内容。打开项目文件夹（这里可以自行修改，推荐使用绝对路径避免出现问题），执行脚本杀死上次运行的后端项目，然后通过git pull --force强行更新（加--force是为了避免冲突导致拉取失败），再执行运行后端的脚本。各个语句之间使用分号分隔。 设置完毕后，Action 脚本就可以正常运作了，这时就可以 commit 观察效果了。 使用 在脚本执行完毕，正常结束后，仓库页面的这个地方可以看到一个蓝色的对号（Github 主题不同，颜色可能不同，不用在意这些细节）： 如果脚本还在执行，看到的是黄色的小点。如果脚本执行过程中发生了异常，则显示一个红叉。点击可以看到详细的执行情况，下图中是一个正确执行的例子： 执行失败的情况： 可以观察到，每个 Action 执行完毕后都会显示一个时间： 这是脚本的执行用时。Github 针对一般的用户，提供了每月 2000 分钟的私有仓库 Action时长（公开的仓库时长不限）。如果超过了这个额度，就要付费。如果完成了学生认证，则是 3000 分钟/月。项目仓库在开发过程中一般都是private状态，所以仓库拥有者需要留意下自己的剩余额度。在个人设置页的Billing下可以看到： 如果两次提交较为接近，导致同时有两个脚本在执行，就可能会导致卡死的情况出现，脚本一直执行不完，疯狂消耗 Action 额度。所以一定要及时留意仓库中的 Action 执行情况，发现异常后手动停止，避免带来财产损失。 实测即使是非常高强度的开发，一个月的时长消耗也在 500 分钟以下，所以可以放心使（bai）用（piao）。 总结 在完成了 Action 的配置之后，后端开发工作就轻松了很多：如果前端发现后端有bug，后端修复完毕并 commit 后，自动触发 Action 进行服务器部署，大约半分钟后，前端即可检测到最新运行的后端。整个过程不再需要连接服务器进行手动更新与部署，非常的方便。 补充 Github Action 脚本是有一个明确的结构规范与语法规则的，这里只是给出了一个非常简单的使用例子。如果想对其深入了解来自己进行魔改，可以阅读这个教程。 var gitalk = new Gitalk({ \"clientID\": \"0cfd2f1628066d69c6e3\", \"clientSecret\": \"303031b18a4deabc1164de81f2d78273c18f8415\", \"repo\": \"Djangobook\", \"owner\": \"Super-BUAA-2021\", \"admin\": [\"zhtjtcz\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); Copyright © Marvolo 2021 all right reserved，powered by Gitbook该文章修订时间： 2022-02-22 12:01:22 "}}